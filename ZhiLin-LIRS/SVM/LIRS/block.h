#ifndef BLOCK_LINEAR
#define BLOCK_LINEAR

#include <cstdio>
#include <vector>
#include <string>
#include <cstring>
#include "linear.h"

using namespace std;

void myfread(void *ptr, size_t size, size_t nmemb, FILE * stream);
int myuncompress(void *dest, size_t *destlen, const void *source, size_t sourcelen);

enum { SINGLE, BINARY, COMPRESSION}; // data format
class BinaryProblem{
	public:
		int l , n;
		BinaryProblem(): l(0), n(0), buf(NULL), buflen(0), bias_idx(-1), bias(-1){}
		~BinaryProblem(){ if(buflen>0) free(buf);}

		void setBias(int idx, double val, int datafmt = COMPRESSION);

		// load problem content from "filename" and internall save as "datafmt"
		void load_problem(const char* filename, int datafmt);

		// return self as a (problem*) prob
		struct problem* get_problem();

		// get a (problem*) subproblem with start_idx = "0" and l = "subl"
		struct problem* get_accproblem(int subl);

		// get a (problem*) subproblem with start_idx = "start" and l = "subl"
		struct problem* get_subproblem(int start, int subl);

		// generate a (BinaryProblem) subproblem according indices "mask"
		void gen_subproblem(BinaryProblem& ret, vector<int> &mask);

	private:
		unsigned char* buf;
		size_t buflen, n_x_space, filelen;
		int bias_idx;
		double bias;
		struct feature_node* x_space;
		struct problem prob, retprob;

		void load_header(FILE *fp);
		void load_body(FILE *fp, int datafmt);
		void parseBinary();
};

class BlockProblem{
	public:
		int nBlocks, n, l, nr_class;
		int datafmt;
		int random_assign;
		double bias;
		char input_file_name[1024];
		vector<string> binary_files;
		vector<int> start;
		vector<int> subl;
		vector<int> label;
		BinaryProblem prob_;

		BlockProblem(): n(0), l(0), datafmt(-1), bias(-1){}
		void setBias(double b);

		// Read a single libsvm-format data.
		void read_single(const char* singlefile, int nsplits = 1);

		// Read a directory generated by blockspliter
		void read_meta(const char* dirname);

		// Get the (problem*) prob of the specified block
		struct problem* get_block(int id);
		
		struct problem* my_get_block(const char* dirname, int id);

		//return problem* prob contains first block to id-block
		struct problem* get_acc_block(int id);
		// Generate (BlockProblem) problem according to blocklist
		BlockProblem genSubProblem(const vector<int>& blocklist);
};


// Return auc, print accuracy
double evaluate_testing(double *w, int n, const problem *prob_t, int positive_label=1);
// Return #correct
double block_testing(double *w, int n,  BlockProblem *bprob);
double primal_value(BlockProblem *bprob, int solver_type, int *y, double C, double *w);
void block_pegasos_as_inner(BlockProblem *bprob, const parameter *param, double *w, double Cp, double Cn);
void block_pegasos(BlockProblem *bprob, const parameter *param, double *w, double Cp, double Cn);
void block_solve_linear_c_svc(BlockProblem *bprob, const parameter *param, double *w, double Cp, double Cn);
void blocktrain_MCSVM_CS(BlockProblem *bprob, const parameter *param, double *w, int nr_class, double *weighted_C);
void blocktrain_one(BlockProblem *bprob, const parameter *param, double *w, double Cp, double Cn);
struct model* blocktrain(BlockProblem* bprob, const  parameter* param);
double block_cross_validation(BlockProblem *bprob, const parameter *param, int nr_fold);

#endif
